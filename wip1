#/usr/bin/python
##https://sammchardy.github.io/async-binance-basics/
##https://python-binance.readthedocs.io/en/latest/
'''
SUMMARY:
Currently utilizes a common day trading strategy of tracking 3 periods of EMAs to predict upswings. Usually this strategy is performed with 3,6,9 EMAs but due to API limitations and the difficulty of calculating EMAs this is using 1,3,5 periods; meaning that this is essentially performing more aggressive short term trading, which after removing the human from the equation may mean it is more efficient.

EMAs are pulled from TAAPI a common api used for trading bots.

Pricing info is pulled from binance API

'Purchases' are currently only done locally and logged to a database for tuning/tweaking of strategies. In the future this will be done on binance testnet, and further in the future will be done with real money on binance live.

THIS IS A WORK IN PROGRESS

================================================================

TO DO:
-Document better/add links to documentation for APIs above
-machine learning?
-implement binance test for better testing
-run tests for profitablity and tweak
-remove prints
-PROGRAM STOP LOSS BEFORE USING REAL MONEY
-merge wait functions with input of str for either buy/sell
-Maybe merge buy and sell functions

should probably also monitor mem/cpu usage to ensure I dont brick my vps
'''
#jesus this is a lot of imports

#for sql stuff
import sqlalchemy
from sqlalchemy import *
import sqlalchemy_utils as su

#frame formatting
import pandas as pd

#async api queries
import asyncio

#binance queries
import binance
from binance.client import Client

#for ema queries
import requests 

#####---MAYBE REMOVE LATER
#literally only for sleep
import time

#literally just for time stamp, maybe replace with time
import datetime

#for importing sensitive API keys
import os
from dotenv import load_dotenv


#keys and connections using keys
key = os.getenv('KEY')
secret = os.getenv('SEC')
client = Client(key, secret)

#sql interface for data queries and storage
engine = sqlalchemy.create_engine('sqlite:///CrypTrans.db')
connection = engine.connect()

#crypto so easily changed
crypto = 'BTC'

#async main for simultaneous api queries
async def main(crypto):
    
    #pulls ema from TAAPI
    async def getema(interval, crypto):
        # Define endpoint - 127 running nodejs api interface
        endpoint = 'http://localhost:4101/indicator'
        
        # Define a parameters dict for the parameters to be sent to the API 
        #more info in TAAPI documentation
        parameters = {
            'indicator': 'zlema',
            'exchange': 'binance',
            'symbol': f'{crypto}/USDT',
            'interval': f'{interval}m',
            'period': '50'
            } 

        # Send get request and save the response as response object 
        response = requests.get(url = endpoint, params = parameters)
        
        # Extract data in json format 
        return response.json() 
    
    #gets ema for period specified
    ema1 = await asyncio.create_task(getema(1, crypto))
    ema3 = await asyncio.create_task(getema(3, crypto))
    ema5 = await asyncio.create_task(getema(5, crypto))
    
    #returns emas in list
    return [ema1.get("value"), ema3.get("value"), ema5.get("value")]

#waits for 1 period ema to cross ABOVE 3 and 5 to SELL
def buywait():
    ema = asyncio.run(main(crypto))
    
    #these vars are pretty useless, DELETE L8r
    ema1 = ema[0]
    ema3 = ema[1]
    ema5 = ema[2]
    
    #loop for waiting
    while ema3 >= ema1 <= ema5:
        ema = asyncio.run(main(crypto))
        
        #more useless vars, delete later
        ema1 = ema[0]
        ema3 = ema[1]
        ema5 = ema[2]
        
        #remove once working
        print(f'hold/sell\n{ema}')
        
        #sleep due to api query limitations
        time.sleep(3)

#waits for 1 period ema to cross BELOW 3 and 5 to SELL
def sellwait():
    
    #these vars are pretty useless, DELETE L8r
    ema = asyncio.run(main(crypto))
    ema1 = ema[0]
    ema3 = ema[1]
    ema5 = ema[2]
    
    #loop for waiting
    while ema3 < ema1 > ema5:
        ema = asyncio.run(main(crypto))
        ema1 = ema[0]
        ema3 = ema[1]
        ema5 = ema[2]
        print(f'hold/buy\n{ema}')
        time.sleep(3)

#sim buy function until testnet is implemented, log purchases to db
def buy():
    
    #ver db exists and queries last row for most recent total of fake money
    if su.database_exists('sqlite:///CrypTrans.db') :
        dbq = connection.execute("SELECT * FROM CrypTrans ORDER BY rowid DESC LIMIT 1")
        #conv dbq which is a cursor mapping to dict
        dbdict = dbq.mappings().all()
        
        #pulls total moneys for calculations
        total = float((dbdict[0].get("Total")))
    else:
        #sets fake money total to 100
        total = 100
    
    #pulls price from binance api
    price = float(client.get_symbol_ticker(symbol=f"{crypto}USDT").get('price'))
    #calculates how much crypto is gotten from that
    amount = total / price
    #no gain/loss on buy
    GL = 'Buy'
    #action taken
    act = 'Buy'
    
    #stuff for timestamp, will probably redo
    now = datetime.datetime.now()
    ts = (now.strftime("%Y-%m-%d %H:%M:%S"))
    
    #converts frame to panda db friendly info and outs to db
    frame = {"Ts": ts, 'ACT': act, 'Cryp': crypto, 'price': price, 'Amount': amount, "G/L": 'GL', 'Total': total}
    df = pd.Dataframe(frame)
    df.to_sql('CrypTrans', engine, if_exists='append')


def sell():  
    #queries db for stuff
    dbq = connection.execute("SELECT * FROM CrypTrans ORDER BY rowid DESC LIMIT 1")
    dbdict = dbq.mappings().all()
    
    #pulls price from binance api
    price = float(client.get_symbol_ticker(symbol=f"{crypto}USDT").get('price'))
    #will be the same as above so omitted for sell
    amount = "Sell"
    #calculates gain/loss maybe
    GL = (price * float(dbdict[0].get('Amount'))) - total
    #action
    act = 'Sell'
    #total monies
    total = GL + dbdict[0].get('Total')
    
    #more timestamp stuff
    now = datetime.datetime.now()
    ts = (now.strftime("%Y-%m-%d %H:%M:%S"))
    
    #frame to DB
    frame = {"Ts": ts, 'ACT': 'Sell', 'Cryp': crypto, 'price': price, 'Amount': amount, "G/L": GL, 'Total': total}
    df = pd.Dataframe(frame)
    df.to_sql('CrypTrans', engine, if_exists='append')
    pass

#loop to run actions continuously
while True:
    #waits for emas to cross to buy
    buywait()
    
    #buy action
    buy()
    
    #waits for emas to cross again to sell
    sellwait()
    
    #sell action
    sell()   



